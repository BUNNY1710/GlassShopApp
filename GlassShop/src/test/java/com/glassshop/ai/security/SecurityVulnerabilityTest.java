package com.glassshop.ai.security;

import static org.junit.jupiter.api.Assertions.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;

/**
 * Security Vulnerability Tests
 * Tests for SQL Injection, XSS, CSRF, unauthorized access
 */
@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
@DisplayName("Security Vulnerability Tests")
class SecurityVulnerabilityTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("SQL Injection Test: Username field")
    void testSqlInjection_Username() throws Exception {
        // Attempt SQL injection in login
        String sqlInjection = "admin' OR '1'='1";
        
        mockMvc.perform(post("/auth/login")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"username\":\"" + sqlInjection + "\",\"password\":\"test\"}"))
                .andExpect(result -> {
                    int status = result.getResponse().getStatus();
                    assertTrue(status >= 400);
                });
        // Should not execute SQL, should return error
    }

    @Test
    @DisplayName("XSS Test: Input sanitization")
    void testXss_Prevented() throws Exception {
        // Attempt XSS in username
        String xssPayload = "<script>alert('XSS')</script>";
        
        mockMvc.perform(post("/auth/register-shop")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"shopName\":\"" + xssPayload + "\",\"email\":\"test@test.com\",\"username\":\"test\",\"password\":\"test123\"}"))
                .andExpect(result -> {
                    int status = result.getResponse().getStatus();
                    assertTrue(status == 200 || status == 400);
                });
        // XSS should be sanitized or rejected
    }

    @Test
    @DisplayName("Unauthorized Access Test: Access protected endpoint without token")
    void testUnauthorizedAccess_NoToken() throws Exception {
        mockMvc.perform(get("/auth/profile"))
                .andExpect(status().isUnauthorized());
    }

    @Test
    @DisplayName("Unauthorized Access Test: Access admin endpoint with STAFF role")
    void testUnauthorizedAccess_WrongRole() throws Exception {
        // This should be tested with actual JWT token for STAFF role
        // For now, we test that the endpoint requires ADMIN
        mockMvc.perform(get("/audit/recent")
                .header("Authorization", "Bearer invalid-token"))
                .andExpect(result -> {
                    int status = result.getResponse().getStatus();
                    assertTrue(status == 401 || status == 403);
                });
    }

    @Test
    @DisplayName("CSRF Test: Verify CSRF protection")
    void testCsrf_Protection() throws Exception {
        // Spring Security should handle CSRF for state-changing operations
        // Since we disabled CSRF for stateless JWT, this test validates that
        mockMvc.perform(post("/auth/login")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"username\":\"test\",\"password\":\"test\"}"))
                .andExpect(result -> {
                    int status = result.getResponse().getStatus();
                    assertTrue(status >= 400);
                });
        // Should work without CSRF token (JWT stateless)
    }

    @Test
    @DisplayName("Path Traversal Test: Prevent directory traversal")
    void testPathTraversal_Prevented() throws Exception {
        String pathTraversal = "../../../etc/passwd";
        
        // Test with path traversal in any input field
        mockMvc.perform(get("/stock/all")
                .param("filter", pathTraversal))
                .andExpect(result -> {
                    int status = result.getResponse().getStatus();
                    assertTrue(status == 200 || status == 400);
                });
        // Should not allow path traversal
    }

    @Test
    @DisplayName("JWT Token Validation: Invalid token format")
    void testJwtToken_InvalidFormat() throws Exception {
        mockMvc.perform(get("/auth/profile")
                .header("Authorization", "Bearer invalid.jwt.token"))
                .andExpect(result -> {
                    int status = result.getResponse().getStatus();
                    assertTrue(status == 401 || status == 403);
                });
    }

    @Test
    @DisplayName("JWT Token Validation: Missing Bearer prefix")
    void testJwtToken_MissingBearer() throws Exception {
        mockMvc.perform(get("/auth/profile")
                .header("Authorization", "test-jwt-token"))
                .andExpect(status().isUnauthorized());
    }

    @Test
    @DisplayName("Input Validation: Empty fields")
    void testInputValidation_EmptyFields() throws Exception {
        mockMvc.perform(post("/auth/login")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"username\":\"\",\"password\":\"\"}"))
                .andExpect(result -> {
                    int status = result.getResponse().getStatus();
                    assertTrue(status >= 400);
                });
    }

    @Test
    @DisplayName("Input Validation: Extremely long input")
    void testInputValidation_LongInput() throws Exception {
        String longInput = "a".repeat(10000);
        
        mockMvc.perform(post("/auth/login")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"username\":\"" + longInput + "\",\"password\":\"test\"}"))
                .andExpect(result -> {
                    int status = result.getResponse().getStatus();
                    assertTrue(status >= 400);
                });
    }
}

